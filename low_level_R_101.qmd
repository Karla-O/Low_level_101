---
title: "Low level 101"
author: "Karla Otoude"
format: html
---
## Vectors, variables, 
###

Rattrape le d√©but !!


## Type and classes

### Types
A limited number of types that can be used to create complicated objects of different classes : 
- logical 
- factor
- list

```{r}
typeof(1)
typeof(2L)
typeof("alice")
typeof(TRUE)
typeof(iris)
typeof(list())
typeof(typeof)
```

### Classes
```{r}
data(iris)
typeof(iris)
class(iris)
```



## Vector

A vector is a collection of values of the same type (by opposition list is an arbitrary collection of values)
Many things in R are vectors (and most of the other things are lists)

```{r}
x <- 15:25
length(x) ## all vectors have a length
x[1]
```
The 'c' function can be seen as a creation function, or, more accurately as a vector concatenation function 


```{r}
y <- c(1, 2, -14, 42)
y
```
Direct access to vector elements is implemented by the bracket operator `[]`. 
Beware that the indexes start at 1. 

```{r}
y[3]
```

```{r}
y[0]
y[-1]
```
Vector of 0 is a numeric because the class of the vector is numeric
vector of -1 removes the first element 

Negative values can be used to "remove" elements 


```{r}
1:6
typeof(1:6)
```
The function seq gives a sequence that starts at the first value, ends at the second and proceed by steps given by the 3rd parameter (here we go 2 by 2)
```{r}
seq(2, 6, 2)
```


### Complex indexing
```{r}
z <- c("Alice", "Bob", "Charlie", "Dylan")
z
z[3:4]
```

```{r}
z
z[2]
z[-1:-3]
```

```{r}
foo <- 10:60
bar <- seq(1, 50, 4)
foo
foo[bar]
```

```{r}
x <- 1:5
y <- c(TRUE, FALSE, FALSE, TRUE, TRUE)
x[y]
```


### Vector oriented calculation

```{r}
x <- 1:5
y <- 6:10
x + y
x - y
x < y
```
Calculations possible because they have the same length

```{r}
x <- 10:20
x - 5
x[x>15]
```
Useful to check various thing about a dataset (compare x under various views)



### Indexing

```{r}
x <- c(6,5,1,2,3,4)
x[3]
```

The indexing operation '[]' does not change the type or the class of the corresponding object

### Double brackets
```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x[1] ## single 
x[(1)] ## double
```

```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x[[2]] <- c ("toto", "bar")
x[[4]] <- 1:15 ## sequence of integers from 1 to 15
x
```

```{r}
x[[c(1, 2)]]
x[[c(3, 2)]]
```

First one interpreted as an index in the list, and the second one is an index in the object (the second element of the list)



```{r}
y <- list(1:4, list(letters[1:5], list(c("foo", "bar"))))
y
y[[2]]
y[[c(2,1)]]
y[[c(2, 2, 1, 2)]]

```
This kind of structure allows us to build a tree 



### Names 
```{r}
z <- list(keys = c("A", "B", "C"), values = c(10, 11, 12), key = c(TRUE, FALSE))
z
z[[1]]
z$keys ## a named access with the dollar operator is similar to the double brackets
z$val ## even if we did not write "values" entirely it searches values (funny but dangerous name completion)
z$key
z$ke ## if the operator searches for a matching element and there are multiple possibilities, the result is "null"
z[["keys"]]
z[["val"]] ## exact matching only (since val does not exist we only get null)
z["values"] ## Only one bracket so it's a list
z["values"] |> class()
z[["values"]] |> class() ## double bracket : so it's a list
```
Remark : a data frame is a list in which every element has the same length




```{r}
names(z) <- c("A", "B", "C")
z
```



## Function

R extensions (packages) consist essentially in collections 

```{r}
names
```
A function is an object that be called by adding parentheses after the function name and possibly parameters inside the parentheses (effective parameters (as opposed to formal parameters)).
Ex : the names function requires as a formal parameter x 



In R function can have multipmle formal parameters and some of them may have default values. When a function is called, one has to specify in general at least the values for the parameters xithout a default value 

```{r}
log(10) ## base taxe the default value (e)
log(10,10) ## now base = 10
```


```{r}
seq
```

```{r}
seq.int
```

```{r}
seq.int(1, 10) ## by is set to 1
seq.int(10, 1) ## by is set to -1
```

### Creating functions 

This is done with the `function` key word
```{r}
my_fun <- function(x, y) ## between parentheses we specify the formal parameters
  ## between the curcly braces {} we describe the operation implemented by the function
  {2*abs(x-y)abs(y)*1e-15}
```
```{r}
my_fun <- function(x, y) { ## between parentheses we specify the formal parameters
  ## between the curcly braces {} we describe the operation implemented by the function
  2 * abs(x - y) * abs(y) * 1e-15
}
```

```{r}
functionBody(my_fun)
```

```{r}
#| echo: false
my_fun() ## cannot work : x and y are missing
```


```{r}
my_fun(2, 1)
my_fun(2, 2)
my_fun(0, 0)
```

Function execution is essentially running the code inside th ebody of the function after replacing the formal parameters by the value used as effective parameters at the call point (call point = where we write the function)

The value of the call is the last value computed in the function (if we write 3 times my fun, the last written is the value)

```{r}
my_fun(4, 1) ## x takes the value 4, and y the value 1 
```


```{r}
my_second_fun <- function(x, y) {
z <- x + y
z/y
z/x
}
```


```{r}
my_second_fun(1, 2)
```

A variable defined in a function is private to the function. It does not care about existing variables with the same name and it disappears just before the end of the function execution 
(it is the case for z here)

```{r}
my_second_fun(1, 2)

z <- 10
my_second_fun(1, 2)
```
Variables inside the function can have the same name as variabels outside of it




