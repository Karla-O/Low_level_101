---
title: "Low level 101"
author: "Karla Otoude"
format: html
---
## Vectors, variables, 
###

Rattrape le d√©but !!


## Type and classes

### Types
A limited number of types that can be used to create complicated objects of different classes : 
- logical 
- factor
- list

```{r}
typeof(1)
typeof(2L)
typeof("alice")
typeof(TRUE)
typeof(iris)
typeof(list())
typeof(typeof)
```

### Classes
```{r}
data(iris)
typeof(iris)
class(iris)
```



## Vector

A vector is a collection of values of the same type (by opposition list is an arbitrary collection of values)
Many things in R are vectors (and most of the other things are lists)

```{r}
x <- 15:25
length(x) ## all vectors have a length
x[1]
```
The 'c' function can be seen as a creation function, or, more accurately as a vector concatenation function 


```{r}
y <- c(1, 2, -14, 42)
y
```
Direct access to vector elements is implemented by the bracket operator `[]`. 
Beware that the indexes start at 1. 

```{r}
y[3]
```

```{r}
y[0]
y[-1]
```
Vector of 0 is a numeric because the class of the vector is numeric
vector of -1 removes the first element 

Negative values can be used to "remove" elements 


```{r}
1:6
typeof(1:6)
```
The function seq gives a sequence that starts at the first value, ends at the second and proceed by steps given by the 3rd parameter (here we go 2 by 2)
```{r}
seq(2, 6, 2)
```


### Complex indexing
```{r}
z <- c("Alice", "Bob", "Charlie", "Dylan")
z
z[3:4]
```

```{r}
z
z[2]
z[-1:-3]
```

```{r}
foo <- 10:60
bar <- seq(1, 50, 4)
foo
foo[bar]
```

```{r}
x <- 1:5
y <- c(TRUE, FALSE, FALSE, TRUE, TRUE)
x[y]
```


### Vector oriented calculation

```{r}
x <- 1:5
y <- 6:10
x + y
x - y
x < y
```
Calculations possible because they have the same length

```{r}
x <- 10:20
x - 5
x[x>15]
```
Useful to check various thing about a dataset (compare x under various views)



### Indexing

```{r}
x <- c(6,5,1,2,3,4)
x[3]
```

The indexing operation '[]' does not change the type or the class of the corresponding object

### Double brackets
```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x[1] ## single 
x[(1)] ## double
```

```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x[[2]] <- c ("toto", "bar")
x[[4]] <- 1:15 ## sequence of integers from 1 to 15
x
```

```{r}
x[[c(1, 2)]]
x[[c(3, 2)]]
```

First one interpreted as an index in the list, and the second one is an index in the object (the second element of the list)



```{r}
y <- list(1:4, list(letters[1:5], list(c("foo", "bar"))))
y
y[[2]]
y[[c(2,1)]]
y[[c(2, 2, 1, 2)]]

```
This kind of structure allows us to build a tree 



### Names 
```{r}
z <- list(keys = c("A", "B", "C"), values = c(10, 11, 12), key = c(TRUE, FALSE))
z
z[[1]]
z$keys ## a named access with the dollar operator is similar to the double brackets
z$val ## even if we did not write "values" entirely it searches values (funny but dangerous name completion)
z$key
z$ke ## if the operator searches for a matching element and there are multiple possibilities, the result is "null"
z[["keys"]]
z[["val"]] ## exact matching only (since val does not exist we only get null)
z["values"] ## Only one bracket so it's a list
z["values"] |> class()
z[["values"]] |> class() ## double bracket : so it's a list
```
Remark : a data frame is a list in which every element has the same length
