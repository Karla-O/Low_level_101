---
title: "Low level 101"
author: "Karla Otoude"
format: html
---
## Vectors, variables, 
###

Rattrape le début !!


## Type and classes

### Types
A limited number of types that can be used to create complicated objects of different classes : 
- logical 
- factor
- list

```{r}
typeof(1)
typeof(2L)
typeof("alice")
typeof(TRUE)
typeof(iris)
typeof(list())
typeof(typeof)
```

### Classes
```{r}
data(iris)
typeof(iris)
class(iris)
```



## Vector

A vector is a collection of values of the same type (by opposition list is an arbitrary collection of values)
Many things in R are vectors (and most of the other things are lists)

```{r}
x <- 15:25
length(x) ## all vectors have a length
x[1]
```
The 'c' function can be seen as a creation function, or, more accurately as a vector concatenation function 


```{r}
y <- c(1, 2, -14, 42)
y
```
Direct access to vector elements is implemented by the bracket operator `[]`. 
Beware that the indexes start at 1. 

```{r}
y[3]
```

```{r}
y[0]
y[-1]
```
Vector of 0 is a numeric because the class of the vector is numeric
vector of -1 removes the first element 

Negative values can be used to "remove" elements 


```{r}
1:6
typeof(1:6)
```
The function seq gives a sequence that starts at the first value, ends at the second and proceed by steps given by the 3rd parameter (here we go 2 by 2)
```{r}
seq(2, 6, 2)
```


### Complex indexing
```{r}
z <- c("Alice", "Bob", "Charlie", "Dylan")
z
z[3:4]
```

```{r}
z
z[2]
z[-1:-3]
```

```{r}
foo <- 10:60
bar <- seq(1, 50, 4)
foo
foo[bar]
```

```{r}
x <- 1:5
y <- c(TRUE, FALSE, FALSE, TRUE, TRUE)
x[y]
```


### Vector oriented calculation

```{r}
x <- 1:5
y <- 6:10
x + y
x - y
x < y
```
Calculations possible because they have the same length

```{r}
x <- 10:20
x - 5
x[x>15]
```
Useful to check various thing about a dataset (compare x under various views)



### Indexing

```{r}
x <- c(6,5,1,2,3,4)
x[3]
```

The indexing operation '[]' does not change the type or the class of the corresponding object

### Double brackets
```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x[1] ## single 
x[(1)] ## double
```

```{r}
x <- list(c(1,2,3), c(TRUE, FALSE), LETTERS[10:15])
x[[2]] <- c ("toto", "bar")
x[[4]] <- 1:15 ## sequence of integers from 1 to 15
x
```

```{r}
x[[c(1, 2)]]
x[[c(3, 2)]]
```

First one interpreted as an index in the list, and the second one is an index in the object (the second element of the list)



```{r}
y <- list(1:4, list(letters[1:5], list(c("foo", "bar"))))
y
y[[2]]
y[[c(2,1)]]
y[[c(2, 2, 1, 2)]]

```
This kind of structure allows us to build a tree 



### Names 
```{r}
z <- list(keys = c("A", "B", "C"), values = c(10, 11, 12), key = c(TRUE, FALSE))
z
z[[1]]
z$keys ## a named access with the dollar operator is similar to the double brackets
z$val ## even if we did not write "values" entirely it searches values (funny but dangerous name completion)
z$key
z$ke ## if the operator searches for a matching element and there are multiple possibilities, the result is "null"
z[["keys"]]
z[["val"]] ## exact matching only (since val does not exist we only get null)
z["values"] ## Only one bracket so it's a list
z["values"] |> class()
z[["values"]] |> class() ## double bracket : so it's a list
```
Remark : a data frame is a list in which every element has the same length




```{r}
names(z) <- c("A", "B", "C")
z
```



## Function

R extensions (packages) consist essentially in collections 

```{r}
names
```
A function is an object that be called by adding parentheses after the function name and possibly parameters inside the parentheses (effective parameters (as opposed to formal parameters)).
Ex : the names function requires as a formal parameter x 



In R function can have multipmle formal parameters and some of them may have default values. When a function is called, one has to specify in general at least the values for the parameters xithout a default value 

```{r}
log(10) ## base taxe the default value (e)
log(10,10) ## now base = 10
```


```{r}
seq
```

```{r}
seq.int
```

```{r}
seq.int(1, 10) ## by is set to 1
seq.int(10, 1) ## by is set to -1
```

### Creating functions 

This is done with the `function` key word

```{r}
my_fun <- function(x, y) { ## between parentheses we specify the formal parameters
  ## between the curcly braces {} we describe the operation implemented by the function
  2 * abs(x - y) * abs(y) * 1e-15
}
```

```{r}
functionBody(my_fun)
```

```{r}
#| echo: false
my_fun() ## cannot work : x and y are missing
```


```{r}
my_fun(2, 1)
my_fun(2, 2)
my_fun(0, 0)
```

Function execution is essentially running the code inside th ebody of the function after replacing the formal parameters by the value used as effective parameters at the call point (call point = where we write the function)

The value of the call is the last value computed in the function (if we write 3 times my fun, the last written is the value)

```{r}
my_fun(4, 1) ## x takes the value 4, and y the value 1 
```


```{r}
my_second_fun <- function(x, y) {
z <- x + y
z/y
z/x
}
```


```{r}
my_second_fun(1, 2)
```

A variable defined in a function is private to the function. It does not care about existing variables with the same name and it disappears just before the end of the function execution 
(it is the case for z here)

```{r}
my_second_fun(1, 2)

z <- 10
my_second_fun(1, 2)
```
Variables inside the function can have the same name as variabels outside of it


### Default parameters

To specify a default value for a parametern we add a equal sign '=' after the formal parametr followed by the default value.
```{r}
x_to_y <- function(x, y=2) {
  x^y
}
```

```{r}
x_to_y(2, 3)
x_to_y(10)
```


Standard called use positional effective parameters : all parameters are specified in the order of the formal parameters. (If x is the first factor in the formal def of the function then x is the first parameter in the call too)

This can be combined with the named effective parmaeters :  the name of the formal parameter is used in the call, followed by an equal sign and the chosen value. In this case the order does not matter anymore. 

```{r}
x_to_y(y = 4, x = 2) ## 2^4

```

Positions and names can be combined if all names are after the unnamed parameters. 
(Here we had to specify the value of x bcs we put y before it, otherwise it would have assumed x was skipped)


### Functions are objects

R has some features of functional languages.

```{r}
all_my_funs <- list(f1 = my_fun, f2 = my_second_fun, f3 = x_to_y)
all_my_funs
```


```{r}
all_my_funs[["f3"]](10, 5.5)
```

```{r}
x <- list(1:3, letters[10:20])
x
```

```{r}
lapply(x, length)
```
`Lapply` applies a function to each of the elements of a list and returns a list made with the results

This also works on vectors (the result is still a list)
```{r}
lapply(1:10, x_to_y)
```


`sapply` tries to simplify the resulting list into a vector (or an array) if the content of the list has a single type 
```{r}
sapply(x, length)
sapply(1:10, x_to_y)
```

if a function is defined like for ex : lapply(X, FUN, ...) the ... means that we can add whatever parameter we want after the 2 first ones


```{r}
#| eval: false
res <- lapply(X, f, toto=2, z=32) ## ??
res[[l]] <- f(X[[l]], toto = 2, z = 32) ## Code à corriger
```

Here w call each element of the 
```{r}
my_data <- list(x = 1:10,
          y = c(NA, 2:5, NA, 6:20))
```



```{r}
lapply(my_data, mean)
```


```{r}
lapply(my_data, mean, na.rm = TRUE)
```

In this version, the parameter 'na.rm' is set to 'TRUE' in all the mean calculations 


### ANonymous functions a.k.a lambdas

Compact function declaration (can be used directly as parameters for example)
```{r}
\(x) x^2
```
```{r}
log(1:10, base = 10)
```
```{r}
sapply(1:10, \(x) 1+log(x))
```
A complicated way to do something simple : 
```{r}
sapply(1:10, \(x,y) 1+y*log(x), y=2)
```

```{r}
1+2*log(1:10)
```

```{r}
my_data <- list(x = 1:10,
                y = c(NA, 2:5, NA, 6:20))
lapply(my_data, mean, na.rm=TRUE)
lapply(my_data, \(x) mean(x, na.rm=TRUE))
lapply(my_data, \(x) 1+2*log(x))
```

Let's say we want to load a list of files : we can use sapply by using a list of files' name and the function read.csv or read.xlsl (excel)


### Closure 

```{r}
power_function <- function(y) {
  \(x)x^y ## closure : a function + some values
}
to_the_cube <- power_function(3)
to_the_cube(1:10)
to_the_cube
\(x, y) x^y
```
The "environment" = the closure of the function 
In the function power_function, we don't have the value of y, we have to call it in order for it to exist and it disappears after the function is executed 

The closure = values that can be taken by y ?

```{r}
x_to_y <- function(x, y) {
  x^y
}
f <- \(x) x_to_y(x, 2)
f(5)
f
```
f = function that maps x to y with y = 2 as something fixed 


```{r}
z <- 3
g <- \(x) x_to_y(x, z)
g(3)
z <- 4
g(3)
g
```
Here in the def of g we are capturing the variable z : meaning that if later on I change the value of z, its going to change the function within g 
(whereas before when we created function, the variables in the function were separated from the variable outside of it)

Here if we delete the variable using rm(z) the function no longer works (g(5) does not work for example)


### Vector "interpolation" (broadcasting in Python)

Why is that working 

```{r}
 x <- c(1,2,3)
x + 1
```

Most operations in R are vectorized : the same operation is applied by default to all elements of a vector, to ease that, vectors can be expanded to match a certain length,  simply by copying the values of a vector a certain number of times.
For instance `1` can be interpreted as `c(1, 1, 1)` if this is needed for a combination with a length 3 vector (as above)

```{r}
x >= 2
```

```{r}
set.seed(42) ## ensure reproducibility by starting the random number generator in state 42 (any integer works)
x <- runif(20, min = -1, max = 1) ## vector of random nb, uniform distribution
x
x > 0
sum(x > 0)
sum(x > mean(x))
x[x <= mean(x)]
length(x[ x > mean(x)]) ##length of values of x larger than its mean
```


```{r}
u <- c(1,2,3)
v <- c(4,5) ## if we duplicate v , we are left with an unused value 
u + v
```

2 is not a multiple of 3 and vice versa so we can't add u (3 elements) and v (2 elements) 

```{r}
u <- c(1,2,3, 4)
v <- c(-1,1) ## here we just need to duplicate v 
u + v
u * v
```

### If else 

We want to compute the Shannon's entropy of a distribution : 

$$
H(p) = \sum_{k=1}^Kp_k\log p_k,
$$

Where $p_K$ is the probaility of observing $k$. A possible naive definition is the following one (see function below):
```{r}
H <- function(x) {
  sum(p*log(p))
}
```


```{r}
rep(1,10) ## replciate 1 ten times
rep(1,10)/10          ## uniform probability over 1 to 10
H(rep(1,10)/10)
```


```{r}
my_dist = c(0,0.5,0.5) # distribution over 1 2 and 3
H(my_dist)
0*log(0) ## Undefined
```


The natural convention to entropy computation is that $p_k\log(p_k)=0$
when  $p_k=0$. We can use `ifelse` to implement that.

```{r}
working_H <- function(p) {
  p_logp <- ifelse(p = 0, p*log(p), 0)
  -sum(p_logp)
}
```


```{r}
working_H(my_dist) ## Corrige avec le cours du prof 
working_H(rep(1, 3)/3)
working_H(c(1, 0, 0))
```

